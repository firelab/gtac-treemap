---
params:
  eval_type:
  raster_name:
  zone_num:
  eval_vars:
  cms_path:
  unique_pltsZone:
  numPltsZone_XdfModel:
  percent_avlbPlts_imputed:
  rat_x_catVarsSummary_df:
title: "TreeMap Zonal Validation: Zone `r params$zone_num` "
subtitle: "`r params$raster_name` ; Eval Type = `r params$eval_type`"
output:
  html_document:
    df_print: paged
  word_document: default
  pdf_document: default
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}

library(flextable)
library(knitr)

# set chunk options
knitr::opts_chunk$set(echo = FALSE)


```


Landfire zone: `r params$zone_num`

Run name: `r params$raster_name` 

Variables to evaluate: `r params$eval_vars`

Evaluation method: `r params$eval_type`

Path for confusion matrices: `r params$cms_path`

Unique plots imputed in zone: `r params$unique_pltsZone`

Plots available in zone: `r params$numPltsZone_XdfModel`

Percent of available plots imputed: `r params$percent_avlbPlts_imputed`%

```{r plot raster}
# plt_time <- Sys.time()

# plotTitle <- as.character(glue::glue("Raw Imputation: Zone {params$zone_num}"))
plotTitle <- glue::glue("Raw Imputation: Zone {params$zone_num}")

if (!exists("pltObj")) {
  # plot raster 
  terra::plot(ras, main = plotTitle, col=rev(terrain.colors(10)), colNA=NULL, legend = TRUE)
  pltObj <- recordPlot()
} else {
  plot.new()
  pltObj
}
```

```{r param table, results = 'asis', warning = F}

if (include_paramTable == "Y"){

  params_RDS_path <- glue::glue('{params_dir}/{output_name}_paramsTable.RDS')
  
  params_csv_path <- glue::glue('{params_dir}/{output_name}_paramsTable.csv')
  
  #load(params_RDS_path)
  
  param_table <- read.csv(params_csv_path)
  
  #param_table <- RDS_toTable(params_RDS_path)
  param_table <- paramsCSV_toFlexTable(param_table)
  
  if (eval_type_in != "TargetLayerComparison"){
    cat("\n\n\\pagebreak\n")
  }
  cat("Run paramters:")
  param_table
  
}


```

```{r for testing: choose single variable to start}
# for testing: choose single variable
# 
#v <- 4
#var_in <- eval_vars_cat[v]
```

```{r format and plot tables for each var, results = 'asis', warning = F}

oaTable <- matrix(ncol = 2, nrow = 0)
colnames(oaTable) <- c("Var", "OA")

if (params$eval_type == "model_eval"){
    eval_vars_cat <- eval_vars_cat[!eval_vars_cat %in% c("disturb_code")]
}

for(v in 1:length(eval_vars_cat)){
  
  var_in <- eval_vars_cat[v]

  cat("\n\n\\pagebreak\n")
  print(glue::glue("**Variable: {var_in}**
  
             "))

  ##### LOOP OVER EACH VAR
  
  cms <- cms_all[[var_in]]
  
  # Initial Table formatting
  ###################################################################################
  
  # Prep frequency table
  #---------------------------------------------#
  
  freq <-
    cms$freq %>%
    #select fields of interest
    dplyr::select(class, ref, pred) %>%
    dplyr::mutate(class = factor(class))
  
  n_classes <- nrow(freq)
  
  # Calculate normalized frequency table 
  #--------------------------------------------#

  # calc total to use in normalizing
  total_pred = sum(freq$pred)
  total_ref = sum(freq$ref)
  
  # add normalized frequency
  freq_norm <- freq %>%
    dplyr::mutate(pred = pred/total_pred, 
           ref = ref/total_ref)
  
  # Join normalized frequency table with reference
  #----------------------------------------------#
  rat_freq <- rat_freq_all[[var_in]]
  rat_freq_norm <- rat_freq
  
  #prep rat frequency table
  rat_freq %<>% 
    dplyr::rename(class = !!var_in, 
           "aRAT" = Freq) %>%
    dplyr::select(-Freq_norm)
  
  
  #prep rat frequency table - normalized
  rat_freq_norm %<>% 
    dplyr::rename(class = !!var_in, 
           "aRAT" = Freq_norm) %>%
    dplyr::select(-Freq)

  # join
  freq %<>%
    dplyr::full_join(rat_freq, by = join_by("class")) %>%
    dplyr::arrange(class)
  
  # join
  freq_norm %<>%
    dplyr::full_join(rat_freq_norm, by = join_by("class")) %>%
    dplyr::arrange(class)
  
  # Format frequency data for plotting - to be used in bar plot
  #---------------------------------------------------------------------------------#

  freq_t2 <- freq_norm %>%
    tidyr::pivot_longer(!class, names_to = "dataset") %>%
    dplyr::rename(frequency = "value") %>%
    dplyr::mutate(dataset= factor(dataset)) %>%
    dplyr::arrange(dataset, class)
  
  # Set NA's to 0
  freq_t2$frequency[is.na(freq_t2$frequency)]<-0

  # Prep CM Classes
  #---------------------------------------------#
  
  # get single cm for classes
  cm_classes <- cms$classes
  
  #manipulate
  cm_classes %<>%
    tidyr::pivot_longer(!metric, names_to = "class") %>%
    dplyr::mutate(class = factor(class)) %>%
    dplyr::mutate(value = round(value, round_dig))
  
  # get number of classes
  nclass = length(unique(cm_classes$class))
  
  # Scatterplot: N of class in reference data vs. classwise accuracy
  # -----------------------------------------------------------------
  
  # get accuracy for each class
  acc <- cm_classes %>%
    dplyr::filter(metric == "Balanced Accuracy")
  
  n_acc <- X_df %>%
    dplyr::select(TM_ID, CN, !!var_in) %>%
    dplyr::rename("class" = !!var_in) %>%
    dplyr::mutate(class = factor(class)) %>%
    dplyr::group_by(class) %>%
    dplyr::summarize(n = n()) %>%
    dplyr::left_join(acc, by = "class")

  # Scatterplot: Total obs of class vs. classwise accuracy
  # -----------------------------------------------------------------#
  
  # get accuracy for each class
  acc <- cm_classes %>%
    dplyr::filter(metric == "Balanced Accuracy")
  
  # join with total N for each class
  freq_acc <- freq %>%
    #select(-X) %>%
    #rename("class" = value) %>%
    dplyr::group_by(class) %>%
    dplyr::summarise(n = ref + pred) %>%
    dplyr::left_join(acc, by = "class")
  
  
  # for evt group - replace group number with long group name for class, for plotting
  #---------------------------------------------------------------------------------#
  if(var_in == "evt_gp") {
    
    freq %<>% 
      left_join(evt_gp_metadata, by = c("class" = "evt_gp")) %>%
      dplyr::mutate(class = evt_gp_n_short) %>%
      select(-c(evt_gp_n, evt_gp_n_short))
    
    freq_norm %<>%
      left_join(evt_gp_metadata, by = c("class" = "evt_gp")) %>%
      dplyr::mutate(class = evt_gp_n_short) %>%
      select(-c(evt_gp_n, evt_gp_n_short))
    
  }
  
  
  
  
  # Prep raw CM
  #------------------------------------------------#
  
  #load cm_raw table
  cm_raw <- as.data.frame.matrix(cms$raw)
  
  # Prep cm overall metrics table
  #------------------------------------------------------#
  
  cm_overall <- cms$overall

  #format
  cm_overall %<>% 
    dplyr::mutate(value = round(value, round_dig))
  
  row.names(cm_overall) <- NULL
  
  
  # Prep confusion matrix for display
  # -------------------------------------------------#
  
  #get overall accuracy 
  oa <- cm_overall %>%
    dplyr::filter(metric == "Accuracy") %>%
    dplyr::select(value) 
  
  oa %<>%
    round(round_dig)
  
  print(glue::glue("*Overall accuracy: {oa*100}%*"))
  
  oaTable <- rbind(oaTable, c(var_in, oa))
  
  var_statSumTable <- params$rat_x_catVarsSummary_df # store passed `params` var to local var to subset by `var_in`
  var_statSumTable <- var_statSumTable[var_in]
  
  cat("\n\nStatistical summary of imputed values:\n\n")
  cat(paste0("- `", unlist(var_statSumTable),"`"), sep = "\n") #https://bookdown.org/yihui/rmarkdown-cookbook/results-asis.html



  # PLOTS
  #------------------------------------------#

  # Include plots based on options set in `04a_run_zonal_report_modularPlotting.R` script:
  # Uses functions from the `evalPlottingFunctionLib.R` library

  if(barPlot_raw == "Y"){
    
    #conditionally add and flip axis labels for evt_gp 
    
    
    barchart1 <- plot_barchart_raw(df = freq, 
                                    var_in = var_in, 
                                    zone_num = zone_num, 
                                    plot_labels = plot_labels, 
                                    save_Plot = save_Plot, 
                                    exportDir = exportDir)
    
    if(var_in == "evt_gp") {
      
      # flip x-axis labels to be vertical
      barchart1 <- barchart1 + 
        theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) + 
        coord_flip()
      
    }
    
    print(barchart1)
    cat("\n\n\\pagebreak\n")
  }
  
  if (barPlot_norm == "Y"){
    
    #conditionally add and flip axis labels for evt_gp
    
    barchart2 <- plot_barchart_norm(df = freq_norm, 
                                  var_in = var_in, 
                                  zone_num = zone_num, 
                                  plot_labels = plot_labels,
                                  save_Plot = save_Plot, 
                                  exportDir = exportDir)
    
    if(var_in == "evt_gp") {
      
      # flip x-axis labels to be vertical
      barchart2 <- barchart2 + 
        theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) + 
        coord_flip()
      
    }
    
    print(barchart2)
  } 

  # Distribution Density
  if(var_in %in% c("evc","evh","disturb_code_bin","disturb_code") & eval_type == "TargetLayerComparison") {
    
    density_plot<- plot_density(df=freq_t2,
                                var_in = var_in, 
                                zone_num = zone_num,
                                save_Plot = save_Plot, 
                                exportDir = exportDir)
  
  # Calculate KL divergence (save to a variable to print with formatting later)
  kl_divergence_x_target <- (paste0("KL divergence between X-table and Target: ", round(suppressMessages(philentropy::KL(x= rbind(freq_t2$frequency[freq_t2$dataset == "ref"], freq_t2$frequency[freq_t2$dataset == "aRAT"]), unit="log2")),4)))
  
  kl_divergence_x_imputation <- (paste0("KL divergence between X-table and Imputation: ", round(suppressMessages(philentropy::KL(x= rbind(freq_t2$frequency[freq_t2$dataset == "pred"], freq_t2$frequency[freq_t2$dataset == "aRAT"]), unit="log2")),4)))
  
  # Print out KL divergence values as a bulleted list and print plot
  cat("\n\n")  
  cat(cat(paste0("- ", kl_divergence_x_target)))
  cat("\n\n")  
  cat((paste0("- ",kl_divergence_x_imputation)))
  print(density_plot)
  
  }
   
  
  
  
  
  
  if (scatterPlot_refVClassAcc == "Y"){
    
    scatter_plot1 <- plot_scatter_refVClassAcc(df = n_acc, 
                                              var_in = var_in, 
                                              zone_num = zone_num, 
                                              save_Plot = save_Plot, 
                                              exportDir = exportDir)

    print(scatter_plot1)

  }
  
  if (scatterPlot_obsVClassAcc == "Y"){
    
    scatter_plot2 <- plot_scatter_obsVClassAcc(df = freq_acc, 
                                              var_in = var_in, 
                                              zone_num = zone_num, 
                                              save_Plot = save_Plot, 
                                              exportDir = exportDir)
    
    print(scatter_plot2)
  }


  
  
  
  # Get producer's and user's accuracy for CM
  #---------------------------------------------------------------------------------------#
    
  # get producer's accuracy for each class - precision
  pa <- cm_classes %>%
    dplyr::filter(metric == "Precision") %>%
    dplyr::mutate(value = round(value, round_dig))  %>%
    dplyr::select(value) %>%
    # replace NA with character
    dplyr::mutate(value = as.character(value)) %>%
    tidyr::replace_na(list(value = "NA")) %>%
    #rename
    dplyr::rename("Prod. Acc" = value) %>%
    # add extra row to be able to bind
    rbind(c("NA"))
    
  # get user's accuracy for each class - recall
  ua <- cm_classes %>%
    dplyr::filter(metric == "Recall") %>% 
    dplyr::mutate(value = round(value, round_dig))  %>%
    dplyr::select(value) %>%
    # replace NA with character
    dplyr::mutate(value = as.character(value)) %>%
    tidyr::replace_na(list(value = "NA")) 
    
  # join producer's accuracy
  cm_display <- cbind(cm_raw, pa)

  #format user's accuracy to be able to bind
  # create list of length that will make it match size of cm_display
  b <- data.frame(value = rep("NA", ncol(cm_display)- nrow(ua)))
  ua <-
    #c("User's Acc") %>%
    rbind(ua, b) %>%
    # rename
    dplyr::rename("User's Acc" = value) %>%
    t() %>%
    data.frame()

  # add names to ua be able to bind
  names(ua) <- names(cm_display)

  #bind ua with cm
  cm_display <- rbind(cm_display, ua)

  # make row names a column
  cm_display$Imputed <- row.names(cm_display)
  row.names(cm_display) <- NULL

  # bind row name column back with df
  cm_display <- cbind(Imputed = cm_display$Imputed, cm_display[1:ncol(cm_display)-1])
  
  # substitute desired column name
  names(cm_display) <- c(cm_labels[1], names(cm_display)[2:ncol(cm_display)])

  # Format flextable
  # - Add contrast background colors for accuracy
  # - Highlight diagonal values

  
  table_cm <- flextable(cm_display) %>%
    # add header and footer
    add_header_row(values = c("", cm_labels[2]), colwidths = c(1, ncol(cm_display)-1)) %>%
    add_footer_row(values = c("Overall accuracy", oa), colwidths = c(ncol(cm_display)-1, 1)) %>%
    # add background color for producer's and user's acc rows
    bg(i = 1:nclass, j = nclass+3, bg = "darkseagreen1") %>%
    bg(i = nclass+2, j = 1:nclass+1, bg = "darkseagreen1") %>%
    # bold text
    style(i = -1:nclass+2, j = c(1,nclass+3), fp_text_default(bold = TRUE)) %>%
    style(i = nclass+2, j = 1:nclass+2, fp_text_default(bold = TRUE)) %>%
    bold(part = "header") %>%
    bold(part = "footer") %>%
    # add background color for overall accuracy
    bg(j = nclass + 3,  bg = "green4", part = "footer")%>%
    # make font smaller
    fontsize(size = 8, part = "all") %>%
    # add borders to body cells
    surround(border = fp_border_default(color = "gray", width = 1), part = "body") %>%
    # add title
    set_caption(glue::glue("Confusion Matrix
             Zone: z{zone_num} ; Attribute: {var_in},
             {plot_labels}"))

  # highlight diagonal values
  for (r in 1:(nrow(cm_display)-1)) {
    table_cm %<>%
    surround(i = r, j = r+1, border = fp_border_default(color = "cornflowerblue", width = 1.5), part = "body")
    }

  # fit to page
  table_cm <- FitFlextableToPage(ft = table_cm,
                                 pgwidth = 7)


  cat(knitr::knit_print(table_cm))
  
  # End loop
}
```


```{r conditionally plot CV figures, results = "asis"}

# conditionally add plots from cross-validation

if(params$eval_type == "CV") {
 
  # list all figures in cross-validation folder
  eval_figs_list <- list.files(glue::glue('{eval_dir}/03_Cross_Validation/figs/'), full.names = TRUE, pattern = ".png$") #TODO: make paths dynamic
  
  evalFig_tmpDir <- glue::glue("{this_proj}/gtac_production_scripts/04_Evaluation/tmp")

  if(!file.exists(evalFig_tmpDir)){dir.create(evalFig_tmpDir)}

  # message(paste0("Moving figs from ", glue::glue('{eval_dir}/03_Cross_Validation/figs/'), " to ", evalFig_tmpDir))
  for (fig in eval_figs_list){
    file.copy(from = fig,
              #to= glue::glue("{tmp_output_dir}/"),
              to = evalFig_tmpDir,
              overwrite = TRUE, recursive = FALSE,
              copy.mode = TRUE)
    }
  
  # initialize list
  tmp_figs_list <- list()
  tmp_figs_list <- list.files(evalFig_tmpDir, full.names = TRUE, pattern = ".png$")
  # print(tmp_figs_list)

  cat("\n\n\\pagebreak\n")
  cat("**Cross-validation (CV) evaluation of continuous variables:**\n\n")
  # render graphics in markdown
  knitr::include_graphics(tmp_figs_list, rel_path = TRUE, error =TRUE)
 
  
}

```
```{r conditionally plot OOB figures, results = "asis"}
if(params$eval_type == "OOB") {

  # list all figures in cross-validation folder
  eval_figs_list <- list.files(glue::glue('{eval_dir}/02_OOB_Manual_Evaluation/figs/'), full.names = TRUE, pattern = ".png$") #TODO: make paths dynamic

  evalFig_tmpDir <- glue::glue("{this_proj}/gtac_production_scripts/04_Evaluation/tmp")

  if(!file.exists(evalFig_tmpDir)){dir.create(evalFig_tmpDir)}

  # message(paste0("Moving figs from ", glue::glue('{eval_dir}/03_Cross_Validation/figs/'), " to ", evalFig_tmpDir))
  for (fig in eval_figs_list){
    file.copy(from = fig,
              #to= glue::glue("{tmp_output_dir}/"),
              to = evalFig_tmpDir,
              overwrite = TRUE, recursive = FALSE,
              copy.mode = TRUE)
    }
  # initialize list
  tmp_figs_list <- list()
  tmp_figs_list <- list.files(evalFig_tmpDir, full.names = TRUE, pattern = ".png$")
  # print(tmp_figs_list) # testing

  cat("\n\n\\pagebreak\n")
  cat("**Out-of-bag (OOB) evaluation of continuous variables:**\n\n")
  # render graphics in markdown
  knitr::include_graphics(tmp_figs_list, rel_path = TRUE, error =TRUE)

}

```

```{r export-eval-metrics-stats-asRDS, echo=FALSE, results='hide', message=FALSE, warning=FALSE}

# Export RDS of model evaluation stats

oaTable_df <- as.data.frame(oaTable)

evaluation_reportStats_list <- list("Landfire_zone"= params$zone_num,
                                    "Year" = year,
                                    "run_name"= params$raster_name,
                                    "eval_type"= params$eval_type,
                                    "unique_pltsInZone" = params$unique_pltsZone,
                                    "plts_availableInZone" = params$numPltsZone_XdfModel,
                                    "percent_availablePlts_imputedInZone" = params$percent_avlbPlts_imputed,
                                    "OA_table" = oaTable_df)

evalTypeDir_dict <- c("model_eval"           = "00_Model_Evaluation", 
                      "TargetLayerComparison"= "01_Target_Layer_Comparison", 
                      "OOB_manual"           = "02_OOB_Manual_Evaluation", 
                      "CV"                   = "03_Cross_Validation")

evalType_subDir <- evalTypeDir_dict[[{eval_type_in}]]

saveRDS(evaluation_reportStats_list, file = glue::glue("{eval_dir}/{evalType_subDir}/{output_name}_{eval_type_in}_STATS.RDS"))

if (exportEvalReportStats == TRUE){
  evalReportRDS <- readRDS(glue::glue("{eval_dir}/{evalType_subDir}/{output_name}_{eval_type_in}_STATS.RDS"))
  listObjects_fromEvalRDS <- evalRDS_toFlexTables(evalReportRDS)
  listObjects_toWord(listObjects = listObjects_fromEvalRDS, 
                     exportDir = glue::glue('{eval_dir}/{evalType_subDir}/'), 
                     exportName = glue::glue("{output_name}_{eval_type_in}_STATS"), 
                     project_name = project_name, 
                     cur_zone_zero = cur_zone_zero, 
                     eval_type = eval_type_in)
}


```