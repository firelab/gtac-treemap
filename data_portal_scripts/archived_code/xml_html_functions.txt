These functions were developed to handle editing xml + html metadata for TreeMap versions. The main xml function is complete, the main html function is missing a key feature for handeling <a href> tags.


CODE:

# List of tuples containing information to edit main dataset metadata for new attribute metadata. PLEASE READ TEXT BELOW TO UNDERSTAND

    # Tuple Parameters

        # Two parameters are common among all tuples
            # metadata_element_path (str) - the path of the element to edit from the metadata
                # e.g., dataqual//attracc//attraccr
                # e.g., eainfo//overview//eaover
            # multiple_specifier (int) - specifies which metadata element to operate on in the case there are multiple of the same element
                # e.g., there are multiple elements that match 'lineage//citeinfo//origin'. If we specify 2, then we will operate on the 2nd element

        # The rest of the parameters differ depending on the operation
            # insert text
                # ('insert text', metadata_element_path, multiple_specifier, new_text, insert_location)
                    # new_text (str) - the new text to insert
                    # insert_location (str) - the existing text that new_text will be inserted after
            # append text
                # ('append text', metadata_element_path, multiple_specifier, new_text)
                    # new_text (str) - the new text to insert
            # new text
                # ('new text', metadata_element_path, multiple_specifier, new_text)
                    # new_text (str) - the new text that will replace the element's existing text
            # replace text
                # ('replace text', metadata_element_path, multiple_specifier, new_text, old_text)
                    # new_text (str) - the new text to insert
                    # old_text (str) - the text to replace
            # delete text
                # ('delete text', metadata_element_path, multiple_specifier, delete_text)
                    # delete_text (str) - the text to delete
            # delete element
                # ('delete element', metadata_element_path, multiple_specifier, delete_dt_label)
                # delete_dt_label (bool) - some elements have labels defined outside their html element (e.g., digform has a dt tag before it with the label 'Digital_Form').
                    #  A value of True will delete the dt tag containing the label, False will not.
                # NOTE: YOU MUST ACCOUNT FOR PREVIOUSLY DELETED ELEMENTS
                    # e.g., if I want to delete the first and third instance of stdorder//digform, 
                    # when the delete operation deletes the first instance, the third instance will now become the second instance
metadata_changes = [('append text', 'idinfo//citation//citeinfo/pubinfo/publish', 1, ' (source data)'),
                    ('delete text', 'idinfo//descript//abstract', 1, ' (the GeoTIFF included in this data publication)'),
                    ('append text', 'idinfo//descript//abstract', 1, '\n\nThis GeoTIFF is a subset of the main TreeMap{tm_ver} dataset, in which a single attribute, {col_name}, has been written to the raster band.'),
                    ('new text', 'eaover', 1, 'Below is a description of the file included in this publication.\n\nIMPORTANT INFORMATION\n\nTreeMap{tm_ver}_{col_name}.tif is a subset of the full TreeMap{tm_ver} dataset. Band values for TreeMap{tm_ver}_{col_name}.tif are those found in the attribute table of the full dataset.\n\n\nDATA FILE DESCRIPTIONS\n\n(1) TreeMap{tm_ver}_{col_name}.tif:\nRaster dataset (GeoTIFF file) representing a single attribute, {col_name}, of the full model output generated by random forests imputation of forest inventory plot data measured by Forest Inventory and Analysis (FIA) to unsampled (and sampled) spatial locations on the landscape for circa 2016 conditions. {col_name} is a measure of {col_description} of the FIA plot CN assigned to each pixel. Predictor variables in the random forests imputation were chosen to optimize the prediction of aboveground forest carbon. These include topographic variables (slope, aspect, and elevation from the FIA PLOT and COND tables), true plot location, vegetation (forest cover, height, and vegetation group assigned to each plot via Forest Vegetation Simulator [FVS, https://www.fs.fed.us/fvs/, Dixon 2002] and LANDFIRE methods), disturbance (years since disturbance and disturbance type as derived from LANDFIRE disturbance rasters), and biophysical variables (maximum and minimum temperature, relative humidity, precipitation, photosynthetically active radiation, and vapor pressure deficit derived by overlay of the plot coordinates with LANDFIRE biophysical rasters). Variables and methods for the full model output are defined in more completeness in Riley et al. (2016) and Riley et al. (2021), the accompanying Data Dictionary file, and the FIA documentation (Burrill et al. 2018).'),
                    ('insert text', 'procstep//procdesc', 1, '\n\n{col_name} was then separated into its own raster by writing values in the raster attribute table to the corresponding pixels in the raster band.', 'landscape data.'),
                    ('new text', 'stdorder//digtinfo//filedec', 2, 'Files zipped with zipfile python library'),
                    ('new text', 'stdorder//networka//networkr', 2, 'https://data.fs.usda.gov/geodata/rastergateway/treemap/'),
                    ('delete element', 'stdorder//digform', 1, True),
                    ('delete element', 'stdorder//digform', 2, True)]


def create_xml_metadata(col_name):
    '''
    Creates XML metadata file for specified attribute based on the main TreeMap dataset XML file.
    
    Args: 
        col_name (str): Name of attribute being processed (e.g. CARBON_D)
        
    Returns:
        None
    '''

    # Parse the original XML file
    tree = ET.parse(treeMapXml)
    root = tree.getroot()

    # Build a map of parent-child relationships. Used in 'delete element' operations
    parent_map = build_parent_map_xml(root)

    # Loop through all the tuples in metadata_changes
    for change in metadata_changes:
        # Get the operation from the tuple
        operation = change[0]
        # Find all the elements that match the path specified in the tuple
        elements = root.findall('.//' + change[1])
        # Select the desired element via the multple_specifier in the tuple
        element = elements[change[2] - 1]

        if operation == 'insert text':
            # Get the new text from the tuple and format with attribute info (tm_ver, col_name, col_description)
            new_text = format_string_att_info(change[3], col_name)
            # Get the insert location specified in the tuple
            insert_location = change[4]
            # Insert the text
            element.text = insert_text_xml(element.text, insert_location, new_text)

        elif operation == 'append text':
            # Get the new text from the tuple and format with attribute info (tm_ver, col_name, col_description)
            new_text = format_string_att_info(change[3], col_name)
            # Append the new text
            element.text = element.text + '\n\n' + new_text

        elif operation == 'new text':
            # Get the new text from the tuple and format with attribute info (tm_ver, col_name, col_description)
            new_text = format_string_att_info(change[3], col_name)
            # Overwrite the existing text with the new text
            element.text = new_text

        elif operation == 'delete text':
            # Get the text to be deleted from the tuple
            delete_text = change[3]
            # Delete the specified text
            element.text = element.text.replace(delete_text, '')

        elif operation == 'delete element':
            # Get the parent element of the element to delete
            parent_element = parent_map[element]
            # Remove the element specified
            parent_element.remove(element)

        else:
            # Inform the user that the operation specified is not valid
            print(change[0] + ' is not a valid operation. Please adjust this tuple: ' + change)

    # Update the metadata creation date
    root.find('.//metd').text = datetime.now().strftime('%Y%m%d')

    # Save the modified XML to a new file in the output folder
    tree.write(os.path.join(outputFolder, f'TreeMap{tm_ver}_{col_name}.xml'))


def build_parent_map_xml(tree):
    '''
    Builds a dictionary map of parent-child relationships.

    Args:
        tree (ElementTree object): The tree to build a map of

    Returns:
        dict: Dictionary of parent-child relationships
    '''

    parent_map = {c: p for p in tree.iter() for c in p}
    return parent_map


def insert_text_xml(full_text, insert_after, new_text):
    '''
    Inserts new text after the specified text.

    Args:
        full_text (str): The main string in which new text will be inserted
        insert_after (str): Text to insert new text after
        new_text (str): New text to be inserted

    Returns:
        str: Modified text with new_text inserted
    '''

    # Find the index of the insert_after text in the full_text
    index = full_text.find(insert_after)

    # If the insert_after text is not found, return the original full_text
    if index == -1:
        return full_text
    
    # Determine the position to insert new text after the provided text
    insert_position = index + len(insert_after)

    # Insert the new text after the insert_after text and return the modified text
    return full_text[:insert_position] + new_text + full_text[insert_position:]


def insert_text_before_xml(element, insert_before, new_text):
    '''
    Inserts new text before the specified text.

    Args:
        element (ElementTree element): Element containing the full text.
        insert_before (str): Text to insert new text before.
        new_text (str): New text to be inserted.

    Returns:
        None.
    '''
    
	# Find the index of the insert_before text in the source text
    index = element.text.find(insert_before)
    
    # If the insert_before text is not found, return the original source text
    if index == -1:
        return

	# Otherwise, insert the new text before the insert_before text
    element.text = element.text[:index] + new_text + element.text[index:]


def format_string_att_info(text, col_name):
    '''
    Checks if a string contains {tm_ver}, {col_name}, or {col_description} and formats it appropriately.

    Args:
        text (str): The text to format
        col_name (str): The column name to insert if needed

    Returns:
        str: Formatted text
    '''

    formatted_text = text

    if '{tm_ver}' in text:
        formatted_text = formatted_text.replace('{tm_ver}', tm_ver)
    if '{col_name}' in text:
        formatted_text = formatted_text.replace('{col_name}', col_name)
    if '{col_description}' in text:
        formatted_text = formatted_text.replace('{col_description}', col_descriptions[col_name])
    
    return formatted_text


def create_html_metadata(col_name):
    '''
    Creates HTML metadata file for specified attribute based on the main TreeMap dataset HTML file. ****INCOMPLETE****
    
    Args:
   	    col_name (str): Name of attribute being processed (e.g. CARBON_D)
   	 
    Returns:
   	    None
    '''

    # Load the HTML content
    with open(treeMapHtml, 'r', encoding='utf-8') as file:
        soup = BeautifulSoup(file, 'html.parser')

    for change in metadata_changes:
        # Get the operation from the tuple
        operation = change[0]
        # Split the path from the tuple so it works with BeautifulSoup
        path = re.split('//|/', change[1])
        # Find all the elements that match the provided path
        elements = find_with_path_html(soup, path)
        # Select the element specified in the tuple
        element = elements[change[2] - 1]

        if operation == 'insert text':
            # Get the new text from the tuple and format with attribute info (tm_ver, col_name, col_description)
            new_text = format_string_att_info(change[3], col_name)
            # Replace new line's with <br /> tags
            new_text = new_text.replace('\n', '<br />')
            # Get the insert location specified in the tuple
            insert_location = change[4].replace('\n', '<br />')
            # Insert the text
            insert_text_html(element, insert_location, new_text)

        elif operation == 'append text':
            # Get the new text from the tuple and format with attribute info (tm_ver, col_name, col_description)
            new_text = format_string_att_info(change[3], col_name)
            # Replace new line's with <br /> tags
            new_text = new_text.replace('\n', '<br />')
            # Separate the text content from the new <br /> tags
            parts = new_text.split('<br />')
    
            # Append the element with the new text and <br /> tags
            for i, part in enumerate(parts):
                element.append(part)
                if i != len(parts) - 1:  # if not the last part, append a <br> tag after
                    element.append(soup.new_tag("br"))

        elif operation == 'new text':
            # Get the new text from the tuple and format with attribute info (tm_ver, col_name, col_description)
            new_text = format_string_att_info(change[3], col_name)
            # Replace new line's with <br /> tags# Replace new line's with <br /> tags
            new_text = new_text.replace('\n', '<br />')
            # Separate the text content from the new <br /> tags
            parts = new_text.split('<br />')

            # Clear any old text from the element (preserves nested <i> tags, which should be labels)
            for content in element.contents[:]:
                if isinstance(content, NavigableString) or (content.name and content.name != 'i'):
                    content.extract()
            print(element)
            print(element.contents)
            print(parts)

            # Add new content to element
            for i, part in enumerate(parts):
                element.append(part)
                if i != len(parts) - 1:  # if not the last part, append a <br> tag after
                    element.append(soup.new_tag("br"))

            print(element)

        elif operation == 'delete text':
            # Get the text to be deleted from the tuple
            delete_text = change[3]

            # Delete the specified text from the element
            for content in element.contents:
                if isinstance(content, NavigableString):
                    content.replace_with(content.replace(delete_text, ''))

        elif operation == 'delete element':
            # If specified to delete the preceding element, get the preceding tag
            if change[3]:
                preceding_tag = element.find_previous_sibling()

            # If there is a preceding tag, delete it
            if preceding_tag:
                preceding_tag.decompose()
            
            # Delete the specified element
            element.decompose()

        else:
            # Inform the user that the operation specified is not valid
            print(change[0] + ' is not a valid operation. Please adjust this tuple: ' + change)

    # Set the metadata creation date
    metadata_date = find_with_path_html(soup, ['metd'])
    metadata_date[0].string = datetime.now().strftime('%Y%m%d')

    # Save the modified HTML to a new file
    with open(os.path.join(outputFolder, f'TreeMap{tm_ver}_{col_name}.html'), 'w', encoding='utf-8') as f:
        f.write(soup.prettify())


def insert_text_html(element, insert_after, new_text):
    # Parse the new_text
    new_content = BeautifulSoup(new_text, 'html.parser')
    
    # Find the position to insert the new content
    found = element.find(string=lambda t: t and insert_after in t)

    if not found:  # If the insert_after text is not found, return the original content
        return

    # Insert text
    found.insert_after(new_content)


def find_with_path_html(soup, tags):
    current_level = [soup]
    for tag in tags:
        next_level = []
        for el in current_level:
            next_level.extend(el.find_all(id=tag))
            next_level.extend(el.find_all(class_=tag))
        current_level = next_level
    return current_level


def update_element_content(element, content_string):
    parsed_content = BeautifulSoup(content_string, 'html.parser')
    element.clear()
    for content in parsed_content.contents:
        element.append(content)


